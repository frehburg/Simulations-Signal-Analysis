package EmpiricalTestForRandomNumberGenerators;

import RandomNumberGenerators.UnifRandGenerator;
import Utils.RoundUtils;
import org.apache.commons.math3.distribution.ChiSquaredDistribution;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * More direct test of the independence assumption and only this. It does not test for uniformity
 */
public class RunsUpTest {
    private static final boolean DEBUG = false;

    /**
     * This tests for the amount of unbroken subsequences of maximal length within which the U_i â€™s
     * increase monotonically in the sequence generated by the random number generator such a sequence
     * is called a run up
     * @param r
     * @param n
     * @return
     */
    public static boolean runsUpTest(UnifRandGenerator r, int n, double alpha) {
        //1. generate n random u
        ArrayList<Double> u = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            u.add(r.getRandomNumber());
        }
        //2. create the counters for runs up
        Integer[] runsUp = new Integer[6];
        for(int i = 0; i < 6; i++) {
            runsUp[i] = 0;
        }

        //3. find run up sequences and count them up
        int lengthRunUp = 1;
        double lastU = u.get(0);
        //takes care of the first element, by already looking at it
        List<Double> uCopy = u.subList(1,u.size());

        for(double curU : uCopy) {
            if(lastU < curU) {
                lengthRunUp++;
            } else {
                //add to counters
                if(lengthRunUp >= 6) {
                    lengthRunUp = 6;
                }
                runsUp[lengthRunUp - 1]++;

                //reset
                lengthRunUp = 1;
            }
            lastU = curU;
        }

        if(DEBUG)System.out.println(Arrays.asList(runsUp));

        //4. initialize the b vector and a matrix
        double[][] a = new double[][] {
                {4529.4, 9044.9, 13568, 18091, 22615, 27892},
                {9044.9, 18097, 27139, 36187, 45234, 55789},
                {13568, 27139, 40721, 54281, 67852, 83685},
                {18091, 36187, 54281, 72414, 90470, 111580},
                {22615, 45234, 67852, 90470, 113262, 139476},
                {27892, 55789, 83685, 111580, 139476, 172860},
        };
        double[] b = new double[]{1.0/6.0, 5.0/24.0, 11.0/120.0, 19.0/720.0, 29.0/5040.0, 1.0/840.0};

        //5. calculate R

        double R = 0;
        for(int i = 0; i < 6; i++) {
            for(int j = 0; j < 6; j++) {
                R += a[i][j] * ((double)runsUp[i] - (double) n * b[i]) * ((double)runsUp[j] - (double) n * b[j]);
            }
        }

        R *= (1.0/ (double) n);

        //6. calculate chi squared value of 6 degrees of freedom with alpha
        ChiSquaredDistribution csd = new ChiSquaredDistribution(6);
        double upperAlphaPercentile = csd.inverseCumulativeProbability(1-alpha); // gets the upper alpha percentile

        //7. if R < chi squared, we accept the u as independent
        boolean independent;
        if(R < upperAlphaPercentile) {
            System.out.println("The Runs Up Independence test found R="+RoundUtils.round(R,2) + "(2dp) and chi squared (6df) =" + RoundUtils.round(upperAlphaPercentile,2) + "(2dp). Therefore we " +
                    "\naccept the hypothesis: the U_i are independent.");
            independent = true;
        } else {
            independent = false;
            System.out.println("The Runs Up Independence test found R="+RoundUtils.round(R,2) + "(2dp) and chi squared (6df) =" + RoundUtils.round(upperAlphaPercentile,2) + "(2dp). Therefore we " +
                    "\nreject the hypothesis: the U_i are not independent.");
        }
        return independent;
    }
}
